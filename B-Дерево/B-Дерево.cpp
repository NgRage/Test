//B-Деревья Фролов

#include <iostream>
#include <fstream>
using namespace std;

const int n = 2;
const int nn = 2 * n;

struct item;
struct page 
{
    short m; //Количество элементов на странице
    page* p0; //Указатель на левую страницу-потомка
    item* e[nn]; //Массив указателей элементов
};

struct item 
{
    long key; //Ключ элемента
    page* p; //Указатель на правую страницу-потомка
    long count; //Количество повторяющихся значений
};


void search(int x, page* a, bool& h, item*& v)
{
    int k, l, r, i;
    page* q, * b;
    item* u = new item;

    if (a == NULL)
    {
        h = true;
        (*v).key = x;
        (*v).count = 1;
        (*v).p = NULL;
    }
    else
    {
        l = 0; // начальный индекс 0
        r = (*a).m - 1; // последний индекс m-1
        do
        {
            k = (l + r) / 2; // Среднее между левым и правым индексами
            if (x < (*(*a).e[k]).key)
            {
                r = k - 1; // Уменьшаем область поиска вправо
            }
            else if (x > (*(*a).e[k]).key)
            {
                l = k + 1; // Увеличиваем область поиска влево
            }
            else 
            {
                (*(*a).e[k]).count++; //Увеличение счетчика повторов
                h = false;
                return;
            }
        } while (l <= r); // условие выхода

        if (r == -1)
        {
            q = (*a).p0; // Берём левый первый указатель
        }
        else
        {
            q = (*(*a).e[r]).p; // Узел находится справа от последнего проверенного ключа
        }
        search(x, q, h, u);

        if (h)
        {
            if ((*a).m < nn)
            {
                // Перенос всех следующих элементов вверх
                for (i = (*a).m; i > r + 1; i--)
                {
                    (*a).e[i] = (*a).e[i - 1];
                }
                (*a).e[r + 1] = u; // Ставим новый элемент на найденное место
                (*a).m++;
                h = false;
            }
            else
            {
                b = new page;
                if (r <= n - 1)
                {
                    // Слева меньше половины элементов
                    if (r == n - 1)
                    {
                        v = u; // Просто оставляем текущее состояние
                    }
                    else
                    {
                        v = (*a).e[n - 1]; // Выбираем средний элемент для переноса
                        for (i = n - 1; i > r + 1; i--)
                        {
                            (*a).e[i] = (*a).e[i - 1]; // Смещаем элементы
                        }
                        (*a).e[r + 1] = u; // Устанавливаем перенесённый элемент
                    }

                    // Копируем половину элементов на новую страницу
                    for (i = 0; i < n; i++)
                    {
                        (*b).e[i] = (*a).e[i + n]; // Передвигаем вторую половину элементов
                    }
                }
                else
                {
                    r = r - n; // Корректировка позиции вставки
                    v = (*a).e[n]; // Средний элемент переносится вверх
                    for (i = 0; i < r; i++)
                    {
                        (*b).e[i] = (*a).e[i + n + 1]; // Пишем ключи на новую страницу
                    }
                    (*b).e[r] = u; // Средний элемент переносится
                    for (i = r + 1; i < n; i++)
                    {
                        (*b).e[i] = (*a).e[i + n]; // Оставшиеся элементы на новую страницу
                    }
                }
                (*a).m = n; // Оставляем на старой странице минимально допустимое число элементов
                (*b).m = n; // Оставляем на новой странице минимально допустимое число элементов
                (*b).p0 = (*v).p; // Связываем новую страницу с правой частью
                (*v).p = b; // Назначаем новую страницу как правую дочернюю
            }
        }
    }
}

void printtree(page* p, int L)
{
    if (p != NULL)
    {
        for (int i = 0; i < L; i++)
        {
            cout << " ";
        }

        for (int i = 0; i < (*p).m; i++)
        {
            cout << (*(*p).e[i]).key << " ";
        }
        cout << endl;

        // Рекурсивная печать левого поддерева
        printtree((*p).p0, L + 1);

        for (int i = 0; i < (*p).m; i++)
        {
            printtree((*(*p).e[i]).p, L + 1); // Рекурсия для каждого правого поддерева
        }
    }
}

//a - страница с нехваткой, c - страница предок
void underflow(page* c, page* a, int s, bool& h)
{
    page* b;
    int i, k, mb, mc;
    mc = (*c).m;

    if (s < mc)
    {
        //Присвоить b страницу справа от а
        b = (*(*c).e[s]).p;
        mb = (*b).m;
        k = (mb - n + 1) / 2; //k - число элементов на страницы b
        (*a).e[n - 1] = (*c).e[s];
        (*(*a).e[n - 1]).p = (*b).p0;
        if (k > 0) 
        {
            //Пересылка k элементов с b на а
            for (i = 1; i < k; i++)
                (*a).e[i + n] = (*b).e[i];
            (*c).e[s] = (*b).e[k - 1];
            (*(*c).e[s]).p = b;
            (*b).p0 = (*(*b).e[k]).p;
            mb = mb - k;
            for (i = 0; i < mb; i++)
                (*b).e[i] = (*b).e[i + k];
            (*b).m = mb;
            (*a).m = n - 1 + k;
            h = false;
        }
        else
        {
            //Слияние страниц a и b
            for (i = 0; i < n; i++)
                (*a).e[i + n] = (*b).e[i];
            for (i = s; i < mc - 1; i++)
                (*c).e[i] = (*c).e[i + 1];
            (*a).m = nn;
            (*c).m = mc - 1;
            h = (*c).m < n;
        }
    }
    else 
    {
        //Присвоить b страницу слева от а
        s--; //Добавлено
        if (s == 0)
            b = (*c).p0;
        else
            b = (*(*c).e[s - 1]).p;
        mb = (*b).m + 1;
        k = (mb - n) / 2;
        if (k > 0) 
        {
            //Пересылка k элементов с b на а
            for (i = n - 2; i >= 0; i--)
                (*a).e[i + k] = (*a).e[i];
            (*a).e[k - 1] = (*c).e[s];
            (*(*a).e[k - 1]).p = (*a).p0;
            mb = mb - k;
            //Переместить k-1 элементов с b на а, один на с
            for (i = k - 2; i >= 0; i--)
                (*a).e[i] = (*b).e[i + mb];
            (*a).p0 = (*(*b).e[s]).p;
            (*c).e[s] = (*b).e[mb - 1];
            (*(*c).e[s]).p = a;
            (*b).m = mb - 1;
            (*a).m = n - 1 + k;
            h = false;
        }
        else 
        {
            //Слияние страницы а и b
            (*(*c).e[s]).p = (*a).p0;
            (*b).e[n] = (*c).e[s];
            for (i = 0; i < n - 1; i++)
                (*b).e[i + n + 1] = (*a).e[i];
            (*b).m = nn;
            (*c).m = mc - 1;
            h = (*c).m < n;
        }
    }
}

//Поиск элемента для замены
void del(page* a, int& r, page* p, bool& h) 
{
    page* q;
    q = (*(*p).e[(*p).m - 1]).p;
    if (q != NULL) 
    {
        del(a, r, q, h);
        if (h)
            underflow(p, q, (*p).m, h);
    }
    else 
    {
        (*(*p).e[(*p).m - 1]).p = (*(*a).e[r]).p;
        (*a).e[r] = (*p).e[(*p).m - 1];
        (*p).m--;
        h = (*p).m < n;
    }
}

//Функция удаления
void Delete(int x, page* a, bool& h) 
{
    int k, l, r;
    page* q;
    if (a == NULL) 
    {
        cout << "Элемента нет в дереве" << endl;
        h = false;
    }
    else
    {
        l = 0;
        r = (*a).m;
        while (l < r) 
        {
            k = (l + r) / 2;
            if (x <= (*(*a).e[k]).key)
                r = k;
            if (x >= (*(*a).e[k]).key)
                l = k + 1;
        }
        if (r == 0)
            q = (*a).p0;
        else
            q = (*(*a).e[r - 1]).p;
        if ((r < (*a).m) && ((*(*a).e[r]).key == x)) 
        {
            //Найден, удаление e[k]
            if (q == NULL) 
            {
                (*a).m--;
                h = (*a).m < n;
                for (int i = k; i < (*a).m; i++)
                    (*a).e[i] = (*a).e[i + 1];
            }
            else 
            {
                del(a, k, q, h);
                if (h)
                    underflow(a, q, r, h);
            }
        }
        else 
        {
            Delete(x, q, h);
            if (h)
                underflow(a, q, r, h);
        }
    }
}

int main()
{
    setlocale(LC_ALL, "Rus");

    page* root = NULL, * q;
    int x, del;
    bool h;
    item* u = new item;
    ifstream f1("1.txt");

    while(!f1.eof())
    {
        cout << "Вводимый ключ: ";
        f1 >> x;
        cout << x << endl;

        search(x, root, h, u);
        if (h)
        {
            q = root;
            root = new page;
            (*root).m = 1;
            (*root).p0 = q; // Старый корень становится первым ребёнком
            (*root).e[0] = u; // Присваиваем вставленный элемент новому корню
            u = new item;
        }
        printtree(root, 1);
    }
    f1.close();

    cout << "Введите значение для удаления: ";
    cin >> del;
    Delete(del, root, h);
    cout << "Дерево после удаления: ";
    printtree(root, 1);
}

/*
Тест 1: (порядок 2):
Введите ключ: 45
 45
Введите ключ: 55
 45 55
Введите ключ: 65
 45 55 65
Введите ключ: 75
 45 55 65 75
Введите ключ: 85
 65
  45 55
  75 85
Введите ключ: 10
 65
  10 45 55
  75 85
Введите ключ: 20
 65
  10 20 45 55
  75 85
Введите ключ: 70
 65
  10 20 45 55
  70 75 85
Введите ключ: 90
 65
  10 20 45 55
  70 75 85 90
Введите ключ: 100
 65 85
  10 20 45 55
  70 75
  90 100

-----------------------------------------------------------------

Тест 2: (порядок 3)
 45
Введите ключ: 55
 45 55
Введите ключ: 65
 45 55 65
Введите ключ: 75
 45 55 65 75
Введите ключ: 85
 45 55 65 75 85
Введите ключ: 10
 10 45 55 65 75 85
Введите ключ: 20
 55
  10 20 45
  65 75 85
Введите ключ: 70
 55
  10 20 45
  65 70 75 85
Введите ключ: 90
 55
  10 20 45
  65 70 75 85 90
Введите ключ: 100
 55
  10 20 45
  65 70 75 85 90 100

-----------------------------------------------------------------

Тест 3: (порядок 5)
Введите ключ: 45
 45
Введите ключ: 55
 45 55
Введите ключ: 65
 45 55 65
Введите ключ: 75
 45 55 65 75
Введите ключ: 85
 45 55 65 75 85
Введите ключ: 10
 10 45 55 65 75 85
Введите ключ: 20
 10 20 45 55 65 75 85
Введите ключ: 70
 10 20 45 55 65 70 75 85
Введите ключ: 90
 10 20 45 55 65 70 75 85 90
Введите ключ: 100
 10 20 45 55 65 70 75 85 90 100

-----------------------------------------------------------------

Тест 4: (19 элементов, порядок 2):
Вводимый ключ: 13
 13
Вводимый ключ: 7
 7 13
Вводимый ключ: 24
 7 13 24
Вводимый ключ: 16
 7 13 16 24
Вводимый ключ: 1
 13
  1 7
  16 24
Вводимый ключ: 10
 13
  1 7 10
  16 24
Вводимый ключ: 14
 13
  1 7 10
  14 16 24
Вводимый ключ: 18
 13
  1 7 10
  14 16 18 24
Вводимый ключ: 25
 13 18
  1 7 10
  14 16
  24 25
Вводимый ключ: 3
 13 18
  1 3 7 10
  14 16
  24 25
Вводимый ключ: 4
 4 13 18
  1 3
  7 10
  14 16
  24 25
Вводимый ключ: 11
 4 13 18
  1 3
  7 10 11
  14 16
  24 25
Вводимый ключ: 15
 4 13 18
  1 3
  7 10 11
  14 15 16
  24 25
Вводимый ключ: 22
 4 13 18
  1 3
  7 10 11
  14 15 16
  22 24 25
Вводимый ключ: 20
 4 13 18
  1 3
  7 10 11
  14 15 16
  20 22 24 25
Вводимый ключ: 21
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25
Вводимый ключ: 26
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 5
 4 13 18 22
  1 3
  5 7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 6
 13
  4 7
   1 3
   5 6
   10 11
  18 22
   14 15 16
   20 21
   24 25 26

-----------------------------------------------------------------

Тест 5: (Удаление без поворотов)
Вводимый ключ: 13
 13
Вводимый ключ: 7
 7 13
Вводимый ключ: 24
 7 13 24
Вводимый ключ: 16
 7 13 16 24
Вводимый ключ: 1
 13
  1 7
  16 24
Вводимый ключ: 10
 13
  1 7 10
  16 24
Вводимый ключ: 14
 13
  1 7 10
  14 16 24
Вводимый ключ: 18
 13
  1 7 10
  14 16 18 24
Вводимый ключ: 25
 13 18
  1 7 10
  14 16
  24 25
Вводимый ключ: 3
 13 18
  1 3 7 10
  14 16
  24 25
Вводимый ключ: 4
 4 13 18
  1 3
  7 10
  14 16
  24 25
Вводимый ключ: 11
 4 13 18
  1 3
  7 10 11
  14 16
  24 25
Вводимый ключ: 15
 4 13 18
  1 3
  7 10 11
  14 15 16
  24 25
Вводимый ключ: 22
 4 13 18
  1 3
  7 10 11
  14 15 16
  22 24 25
Вводимый ключ: 20
 4 13 18
  1 3
  7 10 11
  14 15 16
  20 22 24 25
Вводимый ключ: 21
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25
Вводимый ключ: 26
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 5
 4 13 18 22
  1 3
  5 7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 6
 13
  4 7
   1 3
   5 6
   10 11
  18 22
   14 15 16
   20 21
   24 25 26
Введите значение для удаления: 26
Дерево после удаления:  13
  4 7
   1 3
   5 6
   10 11
  18 22
   14 15 16
   20 21
   24 25

-----------------------------------------------------------------

Тест 6: (Удаление с перемещением)
Вводимый ключ: 13
 13
Вводимый ключ: 7
 7 13
Вводимый ключ: 24
 7 13 24
Вводимый ключ: 16
 7 13 16 24
Вводимый ключ: 1
 13
  1 7
  16 24
Вводимый ключ: 10
 13
  1 7 10
  16 24
Вводимый ключ: 14
 13
  1 7 10
  14 16 24
Вводимый ключ: 18
 13
  1 7 10
  14 16 18 24
Вводимый ключ: 25
 13 18
  1 7 10
  14 16
  24 25
Вводимый ключ: 3
 13 18
  1 3 7 10
  14 16
  24 25
Вводимый ключ: 4
 4 13 18
  1 3
  7 10
  14 16
  24 25
Вводимый ключ: 11
 4 13 18
  1 3
  7 10 11
  14 16
  24 25
Вводимый ключ: 15
 4 13 18
  1 3
  7 10 11
  14 15 16
  24 25
Вводимый ключ: 22
 4 13 18
  1 3
  7 10 11
  14 15 16
  22 24 25
Вводимый ключ: 20
 4 13 18
  1 3
  7 10 11
  14 15 16
  20 22 24 25
Вводимый ключ: 21
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25
Вводимый ключ: 26
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 5
 4 13 18 22
  1 3
  5 7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 6
 13
  4 7
   1 3
   5 6
   10 11
  18 22
   14 15 16
   20 21
   24 25 26
Введите значение для удаления: 21
Дерево после удаления:  13
  4 7
   1 3
   5 6
   10 11
  18 24
   14 15 16
   20 22
   25 26

Тест 7: (Удаление с слиянием)
Вводимый ключ: 13
 13
Вводимый ключ: 7
 7 13
Вводимый ключ: 24
 7 13 24
Вводимый ключ: 16
 7 13 16 24
Вводимый ключ: 1
 13
  1 7
  16 24
Вводимый ключ: 10
 13
  1 7 10
  16 24
Вводимый ключ: 14
 13
  1 7 10
  14 16 24
Вводимый ключ: 18
 13
  1 7 10
  14 16 18 24
Вводимый ключ: 25
 13 18
  1 7 10
  14 16
  24 25
Вводимый ключ: 3
 13 18
  1 3 7 10
  14 16
  24 25
Вводимый ключ: 4
 4 13 18
  1 3
  7 10
  14 16
  24 25
Вводимый ключ: 11
 4 13 18
  1 3
  7 10 11
  14 16
  24 25
Вводимый ключ: 15
 4 13 18
  1 3
  7 10 11
  14 15 16
  24 25
Вводимый ключ: 22
 4 13 18
  1 3
  7 10 11
  14 15 16
  22 24 25
Вводимый ключ: 20
 4 13 18
  1 3
  7 10 11
  14 15 16
  20 22 24 25
Вводимый ключ: 21
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25
Вводимый ключ: 26
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 5
 4 13 18 22
  1 3
  5 7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 6
 13
  4 7
   1 3
   5 6
   10 11
  18 22
   14 15 16
   20 21
   24 25 26
Введите значение для удаления: 6
Дерево после удаления:
  4 13 18 22
   1 3
   5 7 10 11
   14 15 16
   20 21
   24 25 26



   Вводимый ключ: 13
 13
Вводимый ключ: 7
 7 13
Вводимый ключ: 24
 7 13 24
Вводимый ключ: 16
 7 13 16 24
Вводимый ключ: 1
 13
  1 7
  16 24
Вводимый ключ: 10
 13
  1 7 10
  16 24
Вводимый ключ: 14
 13
  1 7 10
  14 16 24
Вводимый ключ: 18
 13
  1 7 10
  14 16 18 24
Вводимый ключ: 25
 13 18
  1 7 10
  14 16
  24 25
Вводимый ключ: 3
 13 18
  1 3 7 10
  14 16
  24 25
Вводимый ключ: 4
 4 13 18
  1 3
  7 10
  14 16
  24 25
Вводимый ключ: 11
 4 13 18
  1 3
  7 10 11
  14 16
  24 25
Вводимый ключ: 15
 4 13 18
  1 3
  7 10 11
  14 15 16
  24 25
Вводимый ключ: 22
 4 13 18
  1 3
  7 10 11
  14 15 16
  22 24 25
Вводимый ключ: 20
 4 13 18
  1 3
  7 10 11
  14 15 16
  20 22 24 25
Вводимый ключ: 21
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25
Вводимый ключ: 26
 4 13 18 22
  1 3
  7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 5
 4 13 18 22
  1 3
  5 7 10 11
  14 15 16
  20 21
  24 25 26
Вводимый ключ: 6
 13
  4 7
   1 3
   5 6
   10 11
  18 22
   14 15 16
   20 21
   24 25 26
Введите значение для удаления: 13
Дерево после удаления:
  4 11 18 22
   1 3
   5 6 7 10
   14 15 16
   20 21
   24 25 26

*/